# Chapter 06. 메시지와 인터페이스

> 오브젝트 : 코드로 이해하는 객체지향 설계 &nbsp; / &nbsp; 조영호 저자 &nbsp; / &nbsp; 위키북스
> * 구입처 &nbsp; : &nbsp; [yes24](http://www.yes24.com/Product/Goods/74219491)
    &nbsp; / &nbsp;[교보문고](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158391409&orderClick=LAG&Kc=)
>  * 저작권을 존중하고자 노력합니다. (문제시 private 하겠습니다. )
>  * 책의 내용과 다릅니다.
>
## reference
* [저자 조영호 님 github](https://github.com/eternity-oop/object)

## 목표
* 1회독 완독, 설계, 객체지향 프로그래밍 학습
* 2021.08.02 ~ 08.08 : chapter 01
* 2021.08.09 ~ 08.15 : chapter 02
* 2021.08.16 ~ 08.22 : chapter 03, 04
* 2021.08.23 ~ 08.29 : chapter 05
* 2021.08.30 ~ 09.05 : chapter 06


---
### 챕터6
- **객체지향 프로그래밍에 대한 가장 흔한 오해**: 애플리케이션이 클래스의 집합으로 구성된다는 것
- **훌륭한 객체지향 코드**: 클래스가 아닌 객체를 지향
- **객체지향 애플리케이션의 가장 중요한 재료**: 객체들이 주고받는 메시지
- 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설계 원칙과 기법을 적용 필요

---

## 01. 협력과 메시지
### 클라이언트 - 서버 모델
- **협력**: 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용
- **클라이언트**: 협력 안에서 메시지를 전송하는 객체
- **서버**: 메시지를 수신하는 객체
- **메시지**: 다른 두 객체 사이의 협력을 가능하게 해주는 매개체

### 메시지와 메시지 전송
- **메시지 전송**: 한 객체가 다른 객체에게 도움을 요청하는 것 (메시지 패싱)
- **메시지 전송자(sender)**: 메시지를 전송하는 객체
- **메시지 수신자(receiver)**: 메시지를 수신하는 객체
- 메시지는 **오퍼레이션명**과 **인자**로 구성되며, 메시지 전송은 여기에 **메시지 수신자**를 추가한 것

### 메시지와 메서드
- **메서드**: 메시지를 수신했을 때, 실제로 실행되는 함수 또는 프로시저
- 객체는 **메시지와 메서드의 개념을 실행 시점에 연결**하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.

### 퍼블릭 인터페이스와 오퍼레이션
- **퍼블릭 인터페이스**: 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합
- **오퍼레이션**
  - 실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세 (추상화)
  - (퍼블릭 인터페이스에 포함된 메시지)

### 시그니처
- **시그니처**: 오퍼레이션의 이름과 파라미터 목록
---
## 02. 인터페이스와 설계 품질
- 좋은 인터페이스는 **최소한의 인터페이스**와 **추상적인 인터페이스**라는 조건을 만족
- 책임 주도 설계 방법
  - 최소주의를 따르면서도 추상적인 인터페이스를 설계할 수 있는 가장 좋은 방법
  - 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지
### 디미터 법칙
- 협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙
- 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한
- 객체가 자기 자신을 책임지는 자율적인 존재여야 한다는 사실을 강조
- 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍
  ```
  - this 객체
  - 메서드의 매개변수
  - this의 속성
  - this의 속성인 컬렉션의 요소
  - 메서드 내에서 생성된 지역 객체 
  ```
- **부끄럼타는 코드**: 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드
- **기차 충돌**: 메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송 (디미터 법칙을 위반한 코드)

### 묻지 말고 시켜라
- **묻지 말고 시켜라**: 필요한 정보를 잘 알고 있는 객체에게 책임을 할당

### 의도를 드러내는 인터페이스
#### **메서드 이름 짓기 첫 번째**: 메서드가 작업을 어떻게 수행하는지를 나타내는 이름
```java
public class PeriodCondition {
  public boolean isSatisfiedByPeriod(Screening screening) { ... }
}

public class SequenceCondition {
  public boolean isSatisfiedBySequence(Screening screening) { ... }
}
```
  > 위 스타일의 코드가 좋지 않은 이유
  >   - 동일한 작업을 하는 메서드임에도 이름이 다르기 때문에, 동일한 작업을 수행한다는 사실을 알아채기 어렵다.
  >  - 메서드들이 클라이언트로 하여금 협력하는 객체의 종류를 알도록 강요한다.
#### **메서드 이름 짓기 두 번째**: '어떻게'가 아니라 '무엇을' 하는지를 드러내는 이름
```java
public class PeriodCondition implements DiscountCondition {
  public boolean isSatisfiedBy(Screening screening) { ... }
}

public class SequenceCondition implements DiscountCondition {
  public boolean isSatisfiedBy(Screening screening) { ... }
}

public interface DiscountCondition {
  boolean isSatisfiedBy(Screening screening);
}
```
- isSatisfiedBy 메서드가 동일한 목적을 가진다는 것을 메서드의 이름을 통해 명확하게 표현
- DiscountCondition 인터페이스를 실체화
- **의도를 드러내는 선택자**: 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴
- **의도를 드러내는 인터페이스**: 의도를 드러내는 선택자를 인터페이스 레벨로 확장

### 함께 모으기
- 디미터 법칙을 위반하는 티켓 판매 도메인
  - 디미터 법칙을 위반하는 설계는 **인터페이스와 구현의 분리 원칙**을 위반
- 묻지 말고 시켜라
```java
public class Audience {
  public Long setTicket(Ticket ticekt) {
    if (bag.hasInvitation()) {
      bag.setTicket(ticket);
      return 0L;
    } else {
      bag.setTicket(ticket);
      bag.minusAmount(ticket.getFee());
      return ticket.getFee();
    }
  }
}
```
- **디미터 법칙 위반**: Audience가 Bag에게 원하는 일을 시키기 전에 hasInvitation 메서드를 이용해 초대권을 가지고 있는지를 묻는다.
- 인터페이스에 의도를 드러내자
  - 오퍼레이션의 의도는 협력이라는 문맥을 반영해야 한다.
---
## 03. 원칙의 함정
- 예외 상황은 있다.
- 원칙이 현재 상황에 부적합하다고 판단되면, 원칙을 무시하라.

### 디미터 법칙은 하나의 도트(.)를 가제하는 규칙이 아니다
```java
IntStream.of(1, 15, 20, 3, 9).filter(x -> x > 10).distinct().count();
```
- IntStream을 받아 IntStream의 인스턴스로 반환하는 조합은 디미터 법칙을 위반하지 않는다.
### 결합도와 응집도의 충돌
- 객체는 내부 구조를 숨겨야 하무로 디미터 법칙을 따르는 것이 좋지만 자료 구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.
---
## 04. 명령-쿼리 분리 원칙
- **명령-쿼리 분리 원칙**
  - 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공
  - 질문이 답변을 수정해서는 안 된다
- **루틴**
  - 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
  - **프로시저**: 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다.
  - **함수**: 값을 반환할 수 있지만 부수효과를 발생시킬 수 없다.
- **명령**과 **쿼리**는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름
  > - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
  > - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.
- **명령-쿼리 인터페이스**: 명령-쿼리 분리 원칙에 따라 작성된 객체의 인터페이스

### 반복 일정의 명력과 쿼리 분리하기
- isSatisfied 메서드가 명령과 쿼리의 두 가지 역할을 동시에 수행하고 있었기 때문에, 버그를 발생시킴
  - isSatisfied 메서드는 Event가 RecurringSchedule의 조건에 부합하는지를 판단한 후 부합할 경우 true를, 부합하지 않을 경우 false를 판단한다. 따라서 isSatisfied 메서드는 개념적으로 쿼리다.
  - isSatisfied 메서드는 Eventrk RecurringSchedule의 조건에 부합하지 않을 경우 Event의 상태를 조건에 부합하도록 변경한다. 따라서 isSatisfied는 실제로는 부수효과를 가지는 명령이다.
### 명령 - 쿼리 분리와 참조 투명성
- 명력과 쿼리를 분리함으로써 명령형 언어의 틀 안에서 **참조 투명성**의 장점을 제한적으로 누릴 수 있다.
- **부수효과**: 컴퓨터의 세계와 수학의 세계를 나누는 가장 큰 특징
- **참조 투명성**: 어떤 표현식이 있을 때, 위치를 변경하더라도 결과가 달라지지 않는 특성
- **불변성**: 어떤 값이 변하지 않는 성질
- 참조 투명성을 만족하는 식이 주는 두 가지 장점
  > - 모든 함수를 이미 알고 있는 하나의 결괏값으로 대체할 수 있기 때문에 식을 쉽게 계산할 수 있다.
  > - 모든 곳에서 함수의 결괏값이 동일하기 때문에 식의 순서를 변경하더라도 각 식의 결과는 달라지지 않는다.
### 책임에 초점을 맞춰라
- 인터페이스 설계 방법: 메시지를 먼저 선택하고, 객체를 선택하는 것
- 이 방식의 긍정적 영향
  - 디미터 법칙: 두 객체 사이의 구조적인 결합도를 낮출 수 있다.
  - 묻지 말고 시켜라: 묻지 말고 시켜라 스타일에 따라 협력을 구조화하게 된다.
  - 의도를 드러내는 인터페이스: 메시지를 전송하는 클라이언트의 관점에서 메시지 이름을 정하면, 의도가 분명하게 드러날 수밖에 없다.
  - 명령-쿼리 분리 원칙: 협력 속에서 객체의 상태를 예측하고 이해하기 쉽게 만들기 위한 방법에 관해 고민하게 되면서, 예측 가능한 협력을 만들기 위해 명령과 쿼리를 분리하게 된다.
- **계약에 의한 설계**: 협력을 위해 클라이언트와 서버가 준수해야 하는 제약을 코드 상에 명시적으로 표현하고 강제할 수 있는 방법
  