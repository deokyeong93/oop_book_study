# Chapter 13. 서브클래싱과 서브타이핑

> 오브젝트 : 코드로 이해하는 객체지향 설계 &nbsp; / &nbsp; 조영호 저자 &nbsp; / &nbsp; 위키북스
>
> - 구입처 &nbsp; : &nbsp; [yes24](http://www.yes24.com/Product/Goods/74219491)

    &nbsp; / &nbsp;[교보문고](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158391409&orderClick=LAG&Kc=)

> - 저작권을 존중하고자 노력합니다. (문제시 private 하겠습니다. )
> - 책의 내용과 다릅니다.

## reference

- [저자 조영호 님 github](https://github.com/eternity-oop/object)

※ 상속의 목적과 의미를 정확히 파악하고 사용하는 것이 이번 장의 핵심


### 상속의 용도 두가지
    - 타입 계층의 구현
		- 부모클래스는 자식 클래스의 일반화이고 자식 클래스는 부모 클래스의 특수화
	- 코드 재사용
		- 상속을 통해 코드를 재사용할 수 있지만 결합도가 높아져서 변경이 어려워진다

* 1차적인 목표 : 타입 계층을 구현하는 것이어야 함, 코드 재사용의 목적은 설계의 변경과 진화를 방해한다.

> 객체지향 프로그래밍: 상속과 다형성을 지원하는 객체기반 프로그래밍   
> 객체기반 프로그래밍: 상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성

* 타입: 우리가 인지하는 세상 사물의 종류
	- 심볼: 타입의 이름에 이름을 붙인것. Ex) ‘프로그래밍 언어’
	- 내연: 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동. 일반적으로 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연을 구성
	- 외연 : 타입에 속하는 객체들의 집합.

> 프로그래밍 관점에서 타입이란 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확히 전달

### 객체지향 패러다임 관점에서의 타입

> 타입의 정의는 곧 퍼블릭 인터페이스의 정의   
> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.   
> ⭐️객체에 중요한 것은 속성이 아니라 행동! 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다.   

- 타입 계층
    - 슈퍼타입: 더 일반적인 타입 (프로그래밍언어)
    - 서브타입: 더 특수한 타입 (객체지향/절차지향 언어)

- 내연관점에서의 일반화: 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정
- 특수화: 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정
- 외연의 관점: 일반적 집합 Ex) 타입스크립트 
- 특수한 집합: 서브셋 Ex) 자바스크립트
    - 더 일반적인 타입의 인스턴스

- 슈퍼타입 
	- 집합이 다른 집합의 모든 멤버를 포함한다
	- 타입 정의가 다른 타입보다 좀 더 일반적이다
	- 서브타입이 정의한 퍼블릭 인터페이스를 일반화 시켜서 상대적으로 범용적이고 넓은 의미로 정의한 것
- 서브타입
	- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다
	- 타입 정의가 다른 타입보다 좀 더 구체적이다.
	- 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다.

> ⭐️일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준이 퍼블릭 인터페이스라는 사실   
즉, 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다!

### 서브클래싱과 서브타이핑

> 상속은 is-a를 만족하며, 자식클래스와 부모클래스 사이의 행동호환성을 만족시켜야한다.

* 펭귄은 새다
* 새는 날수 있다
* is-a 관계, 그러나 펭귄은 날 수 없다!
    - 행동 호환성의 문제


* 기대되는 행동에 따라 타입 계층을 구성해야한다.
* 상속의 적용 여부는 협력과 사용방식에 따라 신중히 적용해도 늦지않다(클라이언트의 요구사항에 집중해라, 자연어에 속지말아라)

* 행동 호환성
> 행동의 호환 여부를 판단하는 것은 클라이언트의 관점이다.


* 클라이언트의 기대에 따라 상속계층 분리하기
> 인터페이스 분리 원칙이라고 부른다. 두 클래스 사이에 행동이 호환되지 않는다면 올바른 타입계층이 아니다.

* 날 수 없는 새와 날 수 있는 새의 두 부류가 존재하며, 펭귄은 후자다.
    - 즉, 상호작용하는 클라이언트의 기대 입장에 맞추어 상속계층을 분리하는게 옳다!
```Java
public clas Bird {
    ...
}

public class FlyingBird extends Bird {
    public void fly() { ... }
    ...
}

public class Penguin extends Bird {
    ...
}

// 이렇게 하면 날수 있는 새에게만 협력 요청이 가능하다
public void flyBird(FlyingBird bird) {
    bird.fly();
}

// 또 다른 방법으로는 인터페이스를 클라이언트 요구사항에 맞게 강제하는것
public interface Flyer {
    fly()
}

public interface Walker {
    walk()
}

/* 더 좋은 방법은 Bird를 약간 수정해서라도 두 가지 퍼블릭 인터페이스에 대해
** 재사용 가능하게 수정하면서 합성을 사용해 유연성을 높이는 방법이 있다.
*/
```
* 위와 같은 방법을 통해 클라이언트의 기대가 변경되더라도 변경의 영향을 최소화 할 수 있다. 
* 이러한 기법을 인터페이스 분리 원칙이라고 부른다(ISP)

### 서브클래싱과 서브타이핑에 대하여 

* 서브클래싱: 코드 재사용이 목적인 구현 상속/클래스 상속
* 서브타이핑: 타입 계층을 구성하기 위해 상속을 사용하는 경우, 행동호환성을 중시하며 인터페이스 상속이라 부름
> 두 가지는 상속을 사용하는 목적에 따라 분리됨   
행동 호환성은 자식클래스가 부모클래스가 사용되는 모든 문맥에서 자식 클래스와 동일하게 행동할 수 있어야 한다. 
* 대체 가능성, 리스코프 치환원칙

### 리스코프 치환원칙
> 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다
* 정사각형은 직사각형이지만, 직사각형이 아닐 수 있다!
    - 현실세상에서 정사각형과 직사각형은 is-a 관계이다.
    - 그러나 실제로는 세로와 가로 길이의 변화 때문에 상속을 통한 메서드 실행이 실패한다!

* 즉, 리스코프 치환원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다.

* 클라이언트가 각각에 대해 전송할 수 있는 메세지와 기대하는 행동이 서로 다르다면 서로 다른 클라이언트와 협력해야한다.

🔴‘클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다’

> 결국, is-a 관계란 '행동이 호환됨'을 전제로 하는 것을 기억하라

```typescript
export class OverlappedDiscountPolicy extends DiscountPolicy {
    constructor(private discountPolicies: Array<disCountPolicy>) {
        this.discountPolicies = new Array(discountPolicies);
    }
    // 타입스크립트 override는 메서드 이름이 같고 타입이 하위거나 같아야함
    @Override
    private getDiscountAmount(screening: Screening): Money {
        let result: Money = Money.ZERO;
        for(const each of this.discountPolicies) {
            result = result + Number(each.calculateDiscountAmount(screening));
        }
        return result;
    }
}
```
* 3장에서 본 위의 형태는 의존성 역전 원칙, 개방-폐쇄 원칙, 리스코프 치환원칙을 잘 지켜 확장 가능한 설계를 달성한 대표적인 예시이다
    - 의존성 역전: 구체 클래스엔 Movie와 OverlappedDiscountPolicy 모두 추상클래스인 DiscountPolicy에 의존한다. 상위 수준 모듈인 Movie와 하위수준 모듈인 OverlappedDiscountPolicy 모두 추상클래스인 DiscountPolicy에 의존한다.
    - 리스코프 치환 원칙: Movie의 관점에서 DiscountPolicy대신 OverlappedDiscountPolicy와 협력해도 아무 문제 없다. 클라이언트에 대한 영향 없이 OverlappedDiscountPolicy 는 DiscountPolicy를 대체할 수 있다.
    - 개방-폐쇄 원칙: 중복 할인 정책을 위해 OverlappedDiscountPolicy를 추가하더라도 Movie에는 영향을 끼치지 않는다.

* 서브타이핑을 달성하기 위해 꼭 상속이 필요한 것은 아니다. 동적 언어에서는 덕타이핑 을 이용하기도 하며 인터페이스를 통해 구현하기도 한다.
* 중요한 것은 어떤 방식이든 리스코프 치환 원칙을 준수해야만 서브타이핑이라고 말할 수 있는 것이다.

### 계약에 의한 설계와 서브타이핑
#### 부록 A를 참고하는것이 좋다.

* 계약에 의한 설계 요소 3가지
    1. 사전 조건
    2. 사후 조건
    3. 클래스 불변식
> 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 '계약'을 준수해야 한다.
* 즉, 클라이언트 입장에서 서브타입은 정말 슈퍼타입의 '한 종류'라는 것.
    - 이것이 서브 클래스와 서브타입이 다른 개념인 이유
    - 모든 상속된 서브클래스가 모두 서브타입인 것이 아니다.
    - 서브타입에 더 강력한 사전조건을 정의할 수 없다.
        - 업캐스팅으로 더 강력한 사전조건을 정의한다면 협력에 실패한다
    - 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
    - 서브타입에 더 약한 사후조건을 정의할 수 없다. 

#### 계약에 의한 설계와 타입계층에 대한 구현을 위한 다양한 방법은 부록 A, B를 참고하자.

