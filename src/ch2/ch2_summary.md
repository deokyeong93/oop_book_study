# Chapter 02. 객체지향 프로그래밍

> 오브젝트 : 코드로 이해하는 객체지향 설계 &nbsp; |&nbsp; 조영호 저&nbsp; |&nbsp; 위키북스
> * 구입처 &nbsp; : &nbsp; [yes24](http://www.yes24.com/Product/Goods/74219491)
    &nbsp; / &nbsp;[교보문고](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158391409&orderClick=LAG&Kc=)
    >  * 저작권을 존중하고자 노력합니다. (문제시 private 하겠습니다. )
    >  * 책의 내용과 다소 다를 수 있습니다.
>

## 스터디 목표
* 1회독 완독
* 2021.08.02 ~ 08.08 : chapter 01 _by Kim SunHwa
* 2021.08.09 ~ 08.15 : chapter 02 _by Kim SunHwa



### 챕터2. 주제
> 객체지향에서 가장 중요한 것은 애플리케이션의 기능을 구현하기 위해 협력에 참여하는 객체들 사이의 상호작용이다.<br>
> 객체들은 협력에 참여하기 위해 역할을 부여받고 역할에 적합한 책임을 수행한다.
>

( 이번 챕터는 큰 개념을 디테일하게 접근해서 반복되는 개념을 요약면에서 고민은 됐으나<br>
그만큼 여러 시각과 경험을 할 수 있는 좋은 내용이었습니다.<br>
제가 생각한 주제 먼저 잡고, 요약을 저자님의 방향성을 따라가 보자 생각했습니다. <br>
방해가 되지 않길 바라며...ㅎㅎ 도움 되면 좋겠습니다.)



---

### 영화 예매 시스템

---

#### 1. 요구사항 살펴보기
* 사용자가 실제 예매하는 대상은 영화가 아니라 상영이다.
* 할인액 규칙
    * 할인 여부 결정 - 할인 조건
    * 할인 요금 결정 - 할인 정책

---

#### 2. 객체지향 프로그래밍을 향해

* 객체를 지향하는 것
    * p.72
      > ... 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것이다.

* 클래스 구현하기
  >  - 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재
  >  - 객체는 스스로 판단하고 행동하는 자율적인 존재
    * 경계의 명확성
        * 내부와 외부
    * **자율적인 객체**
        * 데이터와 기능을 객체 내부로 묶기
        * 외부에서의 접근 통제
            * 접근 제어 (access control) 메커니즘
        * 캡슐화와 접근 제어로 가지는 객체의 2가지
            * public interface
            * implementation
    * 프로그래머의 자유
        * 프로그래머 역할 구분
            * class creator
                * **구현 은닉** implementation hiding
            * client programmer
* ' 설계가 필요한 이유는 변경을 관리 하기 위해서 '


* 협력하는 객체들의 공동체
    * 객체를 이용해 도메인의 의미를 풍부하게 표현 할 수 있다.
        * Money
    * **협력** Collaboration
        * 인스턴스들은 서로의 메서드를 호출하며 상호작용한다.


* 협력에 관한 짧은 이야기
  > ... 메시지와 메서드의 구분에서부터 다형성(polymorphism)의 개념이 출발한다. <br>
  ... 객체가 메시지를 처리하는 방법을 자율적으로 결정 할 수 있다...

---

### 3. 할인 요금 구하기

추상화 (abstraction)

#### 할인 정책과 할인 조건
* 중복코드 제거 ?
    * 공통의 코드 보관

* TEMPLATE METHOD 패턴
  ``` java
    public abstract class DiscountPolicy {
        private List<DiscountCondition> conditions = new ArrayList<>();
    
        public DiscountPolicy(DiscountCondition ... conditions) {
            this.conditions = Arrays.asList(conditions);
        }
    
        public Money calculateDiscountAmount(Screening screening) {
            for(DiscountCondition each : conditions) {
                if (each.isSatisfiedBy(screening)) {
                    return getDiscountAmount(screening);
                }
            }
            return Money.ZERO;
        }
        
        abstract protected Money getDiscountAmount(Screening Screening);
    }
  
  ```

    * 부모 클래스에 기본적 알고리즘의 흐름 구현
        * conditions
            * 중복가능, 다수의 할인 조건을들 담아야 한다.
        * DiscountPolicy 생성자
            * 가변인자를 받는다.
            * <u>this.conditions.add(condition); 와 다른 차이 생각해보기</u>
        * calculateDiscountAmount()
            * 상영에 맞는 할인 조건 선별
            * 할인 금액 반환
    * 중간에 필요한 처리는 자식 클래스에 위임
        * getDiscountAmount()

    * 캡슐화에 대해 생각해 보기

#### 할인 정책 구성하기
> 생성자의 파라미터 목록을 이용해 초기화에 필요한 정보를 전달하도록 ```강제```하면<br>
> 올바른 ```상태```를 가진 객체의 생성을 보장 할 수 있다.

---

### 4. 상속과 다형성
> .. 유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다..

> .. 의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실을 보여준다.


#### 차이에 의한 프로그래밍 **Programming by difference**
* 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법
    * 할인정책과 할인조건에서 중복된 코드 제거를 위해 추상클래스 적용
    * 템플릿 메서드 패턴에서의 부모클래스와 위임 처리


#### 상속과 인터페이스
* **메시지 수신을 통한 협력**
    * 인터페이스 : 객체가 이해할 수 있는 ```메시지```의 목록 정의
* 업캐스팅 upcasting
    * 자식 클래스가 부모 클래스의 타입으로 변환


### 다형성
> 메시지와 메서드는 다른 개념이다.

* 바인딩의 시점
    * 지연 바인딩 or 동적 바인딩
    * 초기 바인딩 or 정적 바인딩

> 인터페이스가 동일해야 한다.

* ps. 객체와 인터페이스?
    * 인터페이스의 코드만 보면 메서드지만
    * "메시지와 수신을 통한 협력"
        * "메시지와 메서드는 다르다"
    * JAVA에서 인터페이스는 (구현체가 없어) 인스턴스화 될 수 없습니다. (new 객체 생성이 불가)
        * 여기서 생각해보면, 인터페이스는 객체간의 메시지를 위해 구현되는 코드로 보입니다.
        * 책에서 언급된 컴파일과 실행시간의 차이도 동일 하구요.
    * +자율적 객체, 차이에 의한 프로그래밍,.. 등 동일 의미로 접근해서 볼 수 있을 거 같습니다.
        * 결국, 객체지향 프로그래밍

---

### 5. 추상화와 유연성

#### 추상의 힘
* 추상화를 이용한 설계는 필요에 따라 표현의 수준을 조정하는 것을 가능하게 해준다.
* 기본적인 애플리케이션의 협력 흐름을 기술한다.
    * 디자인 패턴, 프레임워크
* 설계를 유연하게 만들 수 있다.

#### 유연한 설계

``` java
     public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
```

* **추상화가 유연한 설계를 가능?**
    * 설계가 구체적인 상황에 결합되는 것을 방지하기 때문

* **8장 컨텍스트 독립성** context independency


<br>


#### 추상 클래스와 인터페이스 트레이드 오프

> .. 구현과 관련된 모든 것들이 트레이드오프의 대상이 될 수 있다...<br>
> .. 작성하는 모든 코드에는 합당한 이유가 있어야 한다. ..<br>
> .. 고민하고 트레이드오프하라. <br>

(왠지 멋있네요. ㅋㅋ <br>
아직 챕터2지만, 전 이게 이 책의 주제인거 같아요. <br>
지금까지 코드만 봤으면 안 됏을 것들이 많았지요.<br>
챕터 1. '설계를 구현과 떨어트려서 이야기하는 것은 불가능하다.')


( 클래스부터 고민하는 것에 대해 도메인을 설명하시면서 객체를 생각하도록 하셨고,<br>
중복코드의 공통 보관소로 추상클래스를 예를 드셨지만, 단순 중복이나 공통만으로 상속을 정의하지 않게 하고..<br>
여러 과정들이 있었던거 같아요.  <br>
'트레이드오프' 마지막으로. 한. 번. 더.)<br>
<br>

#### 코드 재사용
* 합성 composition
    * 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법


#### 상속
* 상속의 문제
    * 캡슐화 위반
        * 강한 결 (ch 01)
    * 설계가 유연하지 않다.
        * 컴파일 시점에 관계 결정


#### 합성
* 상속의 2가지 문제 해결
> 인터페이스에 정의된 <u>```메시지```를 통해서만 재사용이 가능</u>하기 때문에 구현을 효과적으로 캡슐화 할 수 있다.<br>
> 상속은 클래스를 통해 강하게 결합되는 데 비해 합성은 ```메시지```를 통해 느슨하게 결합된다.