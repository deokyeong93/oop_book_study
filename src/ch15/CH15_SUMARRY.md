# Chapter 15. 디자인패턴과 프레임워크


> 오브젝트 : 코드로 이해하는 객체지향 설계 &nbsp; / &nbsp; 조영호 저자 &nbsp; / &nbsp; 위키북스
> * 구입처 &nbsp; : &nbsp; [yes24](http://www.yes24.com/Product/Goods/74219491)
    &nbsp; / &nbsp;[교보문고](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158391409&orderClick=LAG&Kc=)
> * 저작권을 존중하고자 노력합니다. (문제시 private 하겠습니다. )
> * 책의 내용과 다릅니다.
>


#### reference
* [저자 조영호 님 github](https://github.com/eternity-oop/object)


<br>


* 디자인 패턴 : 설계의 재사용
  * 변경의 방향 & 주기 이해 &#8594; 필요 책임, 역할들의 협력 방식
  * 협력 템플릿 제공
  * 협력을 일관성 있게 만들기 위한 재사용할 수 있는 설계의 묶음
* 프레임워크 : 설계와 코드를 함께 재사용
  * 각 애플리케이션의 요구에 따라 적절하게 커스터마이징 할 수 있는 확장 포인트 제공
  * 코드 템플릿 제공
  * 일관성 있는 협력을 제공하는 확장 가능한 코드


<br>


### 01 디자인 패턴과 설계 재사용

<br>

#### 소프트웨어 패턴

> 마틴 파울러 <Analysis Patterns> <br>
> (패턴 정의)... 하나의 실무 컨텍스트(practical context) 에서 유용하게 사용해 왔고 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어
>

<br>

* 패턴의 중요 요소 :  **이름**
* 패턴언어,패턴 시스템
  * 연관된 패턴 카테고리 뿐만 아니라 패턴의 생성 규칙과 함께 패턴 언어에 속한 다른 패턴과의 관계 및 협력 규칙 포함

<br>

#### 패턴 분류
* 패턴 범위나 적용 단계에 따라
  * 아키텍처 패턴, 분석 패턴, 디자인 패턴, 이디엄

<br>

* 기술적 문제
  * 디자인 패턴
  * 디자인 패턴 상위 - 아키텍처 패턴
  * 디자인 패턴 하위 - 이디엄
* 도메인 내 개념적 문제
  * 분석 패턴

<br>

#### 패턴과 책임-주도 설계
* 어떤 책임이 필요한가?
* 이 책임을 어떤 객체에게 할당해야 하는가?
* 유연하고 확장 가능한 협력 관계를 구축하기 위해서 객체와 객체 간에 어떤 의존성이 존재해야 하는가?

<br>

* p.518 디자인 패턴의 구성요소가 **역할**과 **책임**이라는 사실을 이해하는 것이 중요
  * "구현 코드가 어떤 디자인 패턴을 따른다" : 역할, 책임, 협력의 관점에서 유사성을 공유 (특정 구현 방식의 강제 X) 

<br>


* STRATEGY 패턴
* BRIDGE 패턴
* OBSERVER 패턴

<br>

* 패턴의 구성 요소 : 역할 (클래스 x)
  * COMPOSITE 패턴
    * 협력에 참여하는 객체들의 역할
      * Component
      * Composite
      * Leaf
    * 패턴 구성 요소 &#8594; **역할** (클래스 X)
      * 역할 &#8594; 동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합 암시
      * 하나의 객체가 여러 역할 수행 o
      * 다수의 클래스가 **동일 역할** 구현 o
  * [rdf](https://jdm.kr/blog/228)
    * 그림 15.1 의 operation()만 공통으로 두고, 전체적으로 사용할 기능들은 Composite에 둔 차이 외에는 동일 (객체들이 동일한 타입으로 핸들링 가능하므로 Composite 패턴)

<br>

#### 캡슐화와 디자인 패턴

* 디자인 패턴의 대부분의 목적은 협력을 일관성 있고 유연하게 만드는 것
  * 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법 정의
  * 구현 방법이나 구조가 아닌, 
    * 어떤 변경을 캡슐화하는지
    * 변경을 캡슐화하기 위해 사용하는 방법을 이해하는 것이 중요


* 변경을 캡슐화 하는 방법
  * 합성
  * 상속


* **STRATEGY 패턴**
  * 목적 - 알고리즘의 *변경을 캡슐화*
  * 구현 위해 **객체 합성** 이용
* **TEMPLATE 패턴** 
  * 알고리즘 캡슐화하기 위해 **상속** 관계 사용
    * 추상 메서드 이용한 *변경을 캡슐화*
      * 부모 클래스가 알고리즘의 기본 구조 정의
      * 구체적 단계는 자식 클래스에서 정의
  * vs STRATEGY 패턴
    * 결합도가 높아 런타임시 객체의 알고리즘 변경 불가능
    * 알고리즘 교체와 같은 요구사항이 없다면 복잡도를 더 낮출수 있는 방법


* **DECORATOR 패턴**
  * 객체의 행동 동적 추가, 객체의 행동 결합하기 위해 객체 합성 사용
  * 선택적인 행동의 개수, 순서에 대한 변경을 캡슐화
  * [java IO](https://docs.oracle.com/javase/tutorial/essential/io/charstreams.htmls)
  ``` java
      inputStream = new BufferedReader(new FileReader("xanadu.txt"));
      outputStream = new PrintWriter(new FileWriter("characteroutput.txt"));
      String l;
      while ((l = inputStream.readLine()) != null) {
        outputStream.println(l);
      }
     // Invoking readLine returns a line of text with the line. CopyLines outputs each line using println, which appends the line terminator for the current operating system.
  ```


* **COMPOSITE 패턴**
  * 예제 OverlappedDiscountPolicy 개별 객체와 복합 객체라는 객체의 수와 관련된 변경을 캡슐화
  * DiscountPolicy 인스턴스가 단일개체인지 복합객체인지 알 필요 없이, 객체의 수 변경하더라도 Movie에 영향 끼치지 않는다.



#### 패턴은 출발점이다

* 목적에 맞게 패턴을 수정하라
  * 패턴을 맹목적으로 사용할 때 많은 문제 발생
  * 설계에 대한 지식과 더불어 패턴에 대한 지식도 함께 공유 필요



<br>


### 02 프레임워크와 코드 재사용

#### 코드 재사용 대 설계 재사용

* 재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다
  * 로버트 L. 글래스 '소프트웨어의 다양성'
    * 다양한 도메인에 재사용 가능한 컴포넌트라는 개념은 비현실적이다.


* 프레임워크
  * 코드를 재사용함으로서 설계 아이디어 재사용

<br>

#### 상위 정책과 하위 정책으로 패키지 분리하기
* **프레임워크의 재사용성 향상**은 **일관성 있는 협력**과 관련이 있다.
  * 핵심재료 - 추상 클래스, 인터페이스
* 객체 지향 이전, 구조적 설계로 전통적 소프트웨어 개발 방법
  * 상위레벨 모듈이 하위레벨 모듈에, 상위정채이 구체적이고 세부적인 사항에 의존하도록 구성
  * 자주 변경되는 세부사항, 변경에 대한 파급효과로 상위정책의 불안정(세부사항에 비해 재사용될 가능성 높다)
* 의존성 역전 원칙에 맞게 상위 정책과 세부사항 모두 추상화에 의존
  * 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리 [컨텍스트 독립성 ch8]
    * 의존성 역전 원리에 따라 추상화에만 의존하도록 의존성의 방향 조정, 추상화를 경계로 패키지 분리


<br>

#### 제어 역전 원리
* **제어 역전 원리** = **할리우드 원리**
  * 의존성을 역전시킨 객체지향 구조에서 반대로 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출
  * 프레임워크 사용시 제어의 흐름의 주체가 이동 (애플리케이션 &#8594; 프레임워크)
  * 프레임워크가 협력을 제어
* **hook**
  * 프레임워크에서 특정 부분으로, 재정의 되거나 제어 역전 원리에 따라 프레임워크가 원하는 시점에 호출


